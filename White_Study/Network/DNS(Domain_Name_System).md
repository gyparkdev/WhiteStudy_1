# DNS(Domain Name System)

---

![Untitled](DNS(Domain_Name_System)/Untitled.png)

# 1. 정의

- DNS 서비스는 전 세계에 배포된 서비스로서, www.example.com과 같이 사람이 읽을 수 있는 이름을 192.0.2.1과 같은 숫자 IP 주소로 변환하여 컴퓨터가 서로 통신할 수 있도록 한다.
    - 인터넷의 DNS 시스템은 이름과 숫자 간의 매핑을 관리하여 마치 전화번호부와 같은 기능을 한다.
    - DNS 서버는 이름을 IP 주소로 변환하여 도메인 이름을 웹 브라우저에 입력할 때 최종 사용자를 어떤 서버에 연결할 것인지를 제어한다. 이 요청을 **쿼리**라고 부른다.

- DNS는 public DNS와 private DNS로 나뉜다.
    - Public DNS
        - 일반적으로 인터넷 서비스 제공업체 (ISP; Internet Service Provider)가 기업에 IP 레코드를 제공한다.
        - 이러한 레코드는 일반 대중에게 제공되며, 사용 중인 디바이스 또는 디바이스에 연결된 네트워크에 상관 없이 누구나 액세스할 수 있다.
    - Private DNS
        - 회사의 방화벽 뒤에 존재하며 내부 사이트의 레코드만을 보관한다는 점에서 Public DNS와 다르다.
        - 이 경우 Private DNS의 범위는 내부 사이트 및 사용되는 서비스의 IP 주소를 기억하는 것으로 제한되며, 프라이빗 네트워크 외부에서 접근할 수 없다.
- 대부분의 경우 사용자는 호스트 이름을 IP 주소로 변환할 때 DNS에 의존한다.

# 2. 유형

![Untitled](DNS(Domain_Name_System)/Untitled%201.png)

- 모든 DNS 서버는 DNS recursor, Root Name Server, TLD Name Server, Authoritative Name Server(SLD Name Server)로 분류된다.
- DNS cache가 존재하지 않는다면 4개의 DNS 서버를 순차적으로 작동하여 요청한 도메인 주소를 IP 주소로 변환해서 Client에 전달하는 작업을 한다.
    - 일반적인 DNS 쿼리에서는 사용자가 입력한 URL이 IP 주소를 제공받기 위해 4개의 서버를 거쳐야 한다.
    - 4개의 서버는 서로 협력하여 클라이언트에 대한 올바른 IP 주소를 가져온다.
- DNS 서버는 Domain Name Space의 계층적 구조에 대한 정보를 저장하고 있는 서버이다.

### **2-1. DNS recursor**

- 리커서는 도서관의 어딘가에서 특정한 책을 찾아달라고 요청받는 사서로 생각할 수 있다.
- DNS recursor는 웹 브라우저 등의 애플리케이션을 통해 클라이언트 컴퓨터로부터 쿼리를 받도록 고안된 서버다.
    - 그런 다음 다른 DNS 서버와 통신하여 올바른 IP 주소를 찾는다.
- DNS recursor는 Client 요청을 받아 Name Server로 전달하고 반환 받은 정보(IP 주소)를 Client에게 알려주는 중계자 역할을 한다.
- 이 과정에서 계층적 구조 트리에서 순차적으로 반환하는 결과를 재귀적으로 탐색한다.
- 재귀적으로 탐색해서 최종 결과를 DNS cache에 저장해 동일한 도메인 주소로 요청을 보내면 재귀적으로 탐색하는 작업을 하지 않고, 즉시 Client에게 IP 주소를 반환해서 불필요한 리소스가 발생하지 않게 할 수 있다.
- 이를 통해 루트 네임서버, TLD(최상위 도메인) 네임서버, 권한 있는 네임서버 등 다른 세 개의 DNS 서버로 전송되는 쿼리를 만든다.

### **2-2. Root Name Server**

- Root Name Server는 계층 구조 트리에서 최상위 경로를 담당하고 있다.
    - 사람이 이해할 수 있는 도메인 네임을 IP 주소로 변환하는 첫 번째 단계로 ICANN이 직접 관리하는 서버이다.
    - 도서관에서 책장 위치를 가리키는 색인으로 생각할 수 있으며, 일반적으로 다른 더욱 특정한 위치에 대한 참조로 사용된다.
- 도메인 주소 맨 뒤에는 대부분 dot`naver.com(.)`이 생략되어 있고, 생략된 dot이 Root Name Server이다.
- 도메인 확장자(`.kr`, `.com`) 레이블을 구분해서 TLD Name Server로 안내한다.

### **2-3. TLD(Top-Level Domain) Name Server**

<aside>
💡 **최상위 도메인 (top-level domain, TLD)**

- 인터넷의 계층적 DNS(도메인 네임 시스템)에서 가장 일반적인 도메인이다.
- TLD는 도메인 네임의 마지막 구성 요소이다(`developer.mozilla.org`의 'org').
- 국제 인터넷 주소 관리 기구(Internet Corporation for Assigned Names and Numbers, ICANN)는 각 TLD를 관리할 조직을 지정한다.
- 관리 조직의 엄격한 정보에 따라, TLD는 웹 사이트의 목적, 소유권 또는 국적에 대한 단서 역할을 하는 경우가 많다.
    - 인터넷 주소 예 ) `https://developer.mozilla.org`
        - 여기서 org는 TLD.
        - mozilla.org는 2차 도메인 이름.
        - developer는 하위 도메인 이름.
        - 이 모든 것이 정규화된 도메인 이름을 구성한다. https://를 추가하면 완전한 URL이 된다.
</aside>

- TLD(Top Level domain) 서버는 도서관의 특정 책장으로 생각할 수 있다.
    - 이 이름 서버는 특정 IP 주소 검색의 다음 단계이며 호스트 이름의 마지막 부분을 호스팅한다.
- Authoritative DNS 서버의 주소를 저장하고 안내하는 역할을 한다.
- example.com 에서 TLD 서버는 com을 의미한다.
    - 만약 `naver.com` 으로 DNS에 요청을 보내게 된다면 Root Name Server를 통해 `.com` 도메인 확장자를 반환 받아서 `.com` 을 관리하는 기관에 `naver.com` 도메인 주소가 존재하는지 확인하여 Authoritative DNS로 안내한다.
- TLD Name Server는 ICANN의 지사인 IANA(Internet Assigned Numbers Authority)가 관리하며, 두가지 서버로 구분한다.
    - 일반 최상위 도메인: 가별로 고유하지 않은 도메인 (`.com`, `.net`)
    - 국가 코드 최상위 도메인: 국가 또는 주와 관련된 모든 도메인이 포함된다. (`.kr`, `.us`)

### **2-4. Authoritative Name Server(SLD Name Server)**

- 일반적으로 DNS 서버에서 가장 마지막 단계로 실제로 DNS 리소스 레코드를 보유하고 담당하는 서버이다.
    - 최종 이름 서버로서, 책장에 있는 사전처럼 특정 이름을 해당 정의로 변환한다.
- 실제 도메인과 IP 주소의 관계가 기록, 저장, 변경되는 서버이다.
- 권한 있는 네임서버는 DNS 쿼리에 대한 실제 답변을 제공한다.
- 권한 있는 이름 서버에는 마스터 서버 또는 기본 이름 서버와 슬레이브 서버 또는 보조 이름 서버의 두 가지 유형이 있다.
    - 마스터 서버는 영역 레코드의 원본 복사본을 보관하고, 슬레이브 서버는 마스터 서버의 정확한 복사본을 유지힌다.
    - DNS 서버 로드를 공유하고 마스터 서버에 장애가 발생할 경우 백업 역할을 한다.
- 권한 있는 이름 서버가 요청한 레코드에 대한 접근 권한이 있다면, 요청한 호스트 이름의 IP 주소를 초기 요청을 한 DNS 리커서(사서)에게 돌려 보낸다.
- 쿼리한 자원 레코드로 응답하는 DNS 조회 체인의 맨 아래에 있는 서버로, 궁극적으로 웹 브라우저가 웹 사이트 또는 다른 웹 자원에 접근하는 데 필요한 IP 주소에 도달하도록 요청할 수 있게 한다.

# 3. **DNS query 유형**

- DNS 클라이언트와 DNS 서버는 DNS 쿼리를 교환하며, 요청과 응답의 사용되는 매개체이다.
- 일반적인 DNS 조회에서는 세 가지 유형의 쿼리가 발생한다.
    - 이러한 쿼리 조합을 사용하면 DNS 확인을 위한 최적화된 프로세스가 되어 이동 거리를 줄일 수 있다.
- 이상적인 상황에서는, 캐시된 레코드 데이터를 사용할 수 있으므로, DNS 이름 서버가 비재귀 쿼리를 반환할 수 있다.

### 3-1. 재귀 쿼리

- Client와 DNS recursor 통신에 사용되는 쿼리이다.
    - 실제 IP 주소를 반환한다.
- 확인자가 레코드를 찾을 수 없는 경우, DNS 클라이언트는 DNS 서버(일반적으로 DNS 재귀 확인자)가 요청한 자원 레코드 또는 오류 메시지를 사용하여 클라이언트에 응답하도록 요구한다.
- Recursive Query와 DNS recursor의 차이를 정확히 인지하고 있어야 한다.
    - Recursive Query는 요청과 응답하는 과정을 포함하는 실제 반환 결과 값이다.
    - DNS recursor는 요청과 응답 과정을 실행하는 서버이다.

### 3-2. 반복 쿼리

- DNS 클라이언트는 DNS 서버가 가능한 최상의 응답을 반환하도록 한다.
- DNS recursor과 Name Server 통신에 사용되는 쿼리이다.
    - DNS recursor에 이미 IP 주소가 캐시되어 있다면 이 과정은 생략한다.
- 쿼리한 DNS 서버가 쿼리 이름과 일치하는 이름을 갖고 있지 않은 경우, 하위 수준의 도메인 네임스페이스에 대해 권한 있는 DNS 서버에 대한 참조를 반환한다.
    - 그 뒤 DNS 클라이언트가 참조 주소를 쿼리한다.
- 이 프로세스는 오류 또는 제한 시간 초과가 발생할 때까지 추가 DNS 서버가 쿼리 체인을 중단한 상태로 계속된다.
    - 반복적으로 쿼리를 보내서 결과물(IP 주소)를 알아내서 DNS recursor에게 IP 주소를 보낸다.

### 3-3. 비재귀 쿼리

- 일반적으로 DNS 확인자 클라이언트의 쿼리를 받은 DNS 서버가 해당 레코드에 대한 권한이 있거나 캐시 내부에 해당 레코드를 갖고 있어, DNS 서버가 접근 권한을 가지고 있는 레코드를 쿼리할 때 발생한다.
- 일반적으로 DNS 서버는 추가 대역폭 소비 및 업스트림 서버의 부하를 방지하기 위해 DNS 레코드를 캐시한다.

# 4. 동작과정

![Untitled](DNS(Domain_Name_System)/Untitled%202.png)

- 사용자가 웹 브라우저에 ‘example.com’을 입력하면, 쿼리가 인터넷으로 이동하고 DNS 재귀 확인자가 이를 수신한다.
- 이어서 확인자가 DNS 루트 이름 서버(.)를 쿼리한다.
- 루트 서버가 도메인에 대한 정보를 저장하는 최상위 도메인(TLD) DNS 서버의 주소로 확인자에 응답한다.
    - example.com을 검색할 경우의 요청은 .com TLD가 된다.
- 확인자가 .com TLD에 요청한다
- TLD 서버가 도메인 이름 서버(example.com)의 IP 주소로 응답한다.
- 재귀 확인자가 도메인의 이름 서버로 쿼리를 보낸다.
- example.com의 IP 주소가 이름 서버에서 확인자에게 반환된다.
- DNS 확인자가 처음 요청한 도메인의 IP 주소로 웹 브라우저에게 응답한다.
- 브라우저가 IP 주소로 HTTP 요청을 보낸다.
- 해당 IP 서버가 브라우저에서 렌더링할 웹 페이지를 반환한다.

> 단, DNS 정보가 캐시되어 있다면 위의 DNS 조회 프로세스에서 몇 단계는 건너 뛰어질 수 있다.
> 

- **동작과정 예시 1**
    
    ![Untitled](DNS(Domain_Name_System)/Untitled%203.png)
    
    1. 브라우저(Client)에 `naver.com` 입력하면 Recursive Query가 DNS Recursor로 요청을 보낸다.
    2. DNS Recursor에서 DNS cache 유무를 확인한다.
    3. 만약 DNS cache가 존재하지 않는다면 DNS Recursor에서 Iterative Query가 Root Name Server로 요청을 보낸다.
    4. Root Name Server에서 DNS Recursor로 도메인 확장자 `.com` 을 반환한다.
    5. 반환 받은 쿼리를 DNS Recursor는 Iterative Query 형태로 TLD Name Server로 보내서 `.com` 을 관리하는 기관에서 `naver.com` 이 존재하는지 확인 후 쿼리를 DNS Recursor로 보낸다.
    6. DNS Recursor는 Authoritative Name Server에 실제 도메인 주소와 동일한 주소가 있는지 확인하기 위해 Iterative Query를 보내서 IP 주소를 반환한다.
    7. 6번 과정에서 DNS cache를 저장해서 불필요한 리소스가 발생하는 문제를 예방한다.
    8. 이어서, DNS Recursor는 처음 요청한 도메인가 매핑된 IP 주소로 웹 브라우저에게 응답한다.
    9. 브라우저가 IP 주소로 HTTP 요청을 보낸다.
    10. IP 주소의 서버가 브라우저에서 렌더링할 웹 페이지를 반환한다.
- **동작과정 예시 2**
    1. 웹 브라우저는 해결사 서버에게 요청한다.
        ◦ “www.abc.kr의 IP 주소를 알려주세요.”
    2. 해결사 서버는 최상위 기관에서 관리하는 네임서버에게 요청한다.
        ◦ ”.kr 이라는 도메인 있나요?”
    3. 최상위 기관에서 관리하는 네임 서버는 응답한다.
        ◦ “.kr 한국 국가 도메인 입니다. .kr 네임 서버로 가보세요!”
    4. 해결사 서버는 이제는 .kr 네임 서버에게 요청한다.
        ◦ “abc[.kr](https://hanamon.kr/) 있나요?”.
    5. kr 네임 서버는 응답한다.
        ◦ “네 가비아로 가세요~”
        ◦ (”xyz[.kr](http://hakunamatata.kr/) 있나요?” 라고 물어봐도 “네 가비아로 가세요~”라고 응답한다.)
    6. 해결사 서버는 가비아 네임 서버에게 요청한다.
        ◦ “[www.abc.kr](http://www.hanamon.kr/) 있나요?”가비아 네임 서버는 응답한다.
        ◦ 네 12.345.678.900 으로 가세요!”
    7. 해결사 서버는 웹 브라우저에게 알려준다.
        ◦ 네 12.345.678.900 으로 가세요!”

### 4-1. DNS Resolver

![Untitled](DNS(Domain_Name_System)/Untitled%204.png)

- DNS 확인자는 DNS 조회의 첫 번째 중단점이며, 최초 요청을 한 클라이언트 처리를 담당한다.
- 확인자는 URL이 궁극적으로 필요한 IP 주소로 변환되도록 하는 일련의 쿼리를 시작한다.
    - 캐시 되지 않은 일반적인 DNS 조회에는 재귀 쿼리와 반복 쿼리가 모두 포함된다.
- Resolver는 DNS 서버에 조회 메시지를 보내며 거기에 반송되는 응답 메시지를 클라이언트에게 전달한다.
- 즉, DNS Resolver는 Name Resoultion을 실행하는 역할을 수행한다고 할 수 있다.
    - ⇒ Name Resoultion : DNS 원리를 사용하여 IP 주소를 조사하는 것.
- DNS Reolsver는 Socket 라이브러리에 들어있는 부품화된 프로그램이다.
    - 이를 통해 애플리케이션에서 간단히 Resolver를 호출하여 이용할 수 있다.
- 도메인명에서 IP 주소를 조사할 때 브라우저는 Socket 라이브러리의 Resolver를 이용한다.

- 리졸버는 웹 브라우저와 같은 DNS 클라이언트의 요청을 네임 서버로 전달하고 네임 서버로부터 정보(도메인 이름과 IP주소)를 받아 클라이언트에게 제공하는 기능을 수행한다.
- 이 과정에서 리졸버는 하나의 네임 서버에게 DNS 요청을 전달하고 해당 서버에 정보가 없으면 다른 네임 서버에게 요청을 보내 정보를 받아온다.
- 리졸버는 수많은 네임서버에 접근하여 사용자로부터 요청 받은 도메인의 IP정보를 조회하는 기능을 수행한다.
- 그러나, 리졸버 기능을 단말에 구현하는 것은 자원의 한계가 있어, 대부분의 기능을 DNS서버에 구현하고 클라이언트 호스트는 리졸버의 단순한 기능만을 지닌 리졸버 루틴을 구현하는 옵션이 제시되어 있다.
    - 이러한 리졸버를 스터브 리졸버(Stub Resolver)라고 한다.
    - 이 리졸버는 수 많은 네임 서버의 구조를 파악할 필요 없이 리졸버가 구현된 DNS 서버의 IP 주소만 파악하면 된다.
    - 클라이언트 호스트에서 설정하는 DNS 서버(Recursive DNS Server)는 이와 같은 서버를 의미하는 것으로, 도메인에 대한 질의를 받은 스터브 리졸버는 설정된 DNS 서버로 DNS Query(질의)를 전달하고 DNS 서버로부터 최종 결과를 응답 받아 웹 브라우저로 전달하는 인터페이스 기능만을 수행한다.

### 4-2. DNS Cache

![Untitled](DNS(Domain_Name_System)/Untitled%205.png)

- 캐싱의 목적은 데이터를 임시 저장하여, 데이터 요청에 대한 성능과 신뢰성을 높이는 것이다.
- DNS 캐싱은 요청하는 클라이언트와 가까운 곳에 데이터를 저장함으로써, DNS 쿼리를 조기에 확인할 수 있고 DNS 조회 체인의 추가 쿼리를 피할 수 있으므로, 로드 시간이 향상되고 대역폭/CPU 소비가 줄어든다.
- DNS 데이터는 다양한 위치에 캐시될 수 있으며, 각 위치는 TTL(Time-To-Live)에 의해 정의된 설정 시간 동안 DNS 레코드를 저장한다.
- 상위와 하위의 도메인을 같이 등록하는 경우, 상위 DNS 서버에 조회하면 하위 DNS 서버를 한 개 건너뛰고, 그 아래 DNS 서버에 관한 정보가 돌아온다.
    - 즉, 최상위 루트 도메인에서 차례대로 따라가는 원칙과 달리 움직일 수 있다.
- DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있으며, 조회한 이름에 해당하는 정보가 캐시에 있으면 그 정보를 회답함으로서 그 자리에서 계층 구조를 아래로 향하여 찾을 수 있다.
- 단, 정보라는 것이 반드시 DNS 서버 위치에 대한 정보를 함축하지 않는다. 조회한 이름이 등록되지 않은 경우에도 이름이 존재하지 않는다는 정보 역시 캐시에 보존할 수 있다.
- 도메인을 쿼리하는데 있어 먼저 OS → Local 캐시를 조회하고 Local 캐시에 없는 도메인을 DNS 서버로 쿼리한다.
    
    ### 가. 브라우저 DNS 캐싱
    
    - 최신 웹 브라우저는 기본적으로 정해진 시간 동안 DNS 레코드를 캐시하도록 설계되었다.
    - 그 목적은 DNS 캐싱이 웹 브라우저와 가까울수록 캐시를 확인하고 IP 주소에 대한 올바른 요청을 하기 위해 처리해야 할 단계가 적어진다.
    - DNS 레코드를 요청할 때 브라우저 캐시에서 처음으로 요청한 레코드를 확인하는 것이다.
    
    ### 나. OS 수준 DNS 캐싱
    
    - 운영 체제 수준 DNS 확인자는 DNS 쿼리가 컴퓨터를 떠나기 전의 두 번째 중단점이며, 로컬에 있는 마지막 중단점이다.
    - 이 쿼리를 처리하도록 설계된 OS 내부의 프로세스를 일반적으로 Stub 확인자 또는 DNS 클라이언트라고 한다.
    - 스텁 확인자는 애플리케이션에서 요청을 받으면 먼저 자체 캐시를 검사하여 레코드가 있는지 확인한다.
    - 레코드가 없으면 로컬 네트워크 외부의 (재귀 플래그가 설정된) DNS 쿼리를 ISP 내부의 DNS 재귀 확인자로 보낸다.
    - ISP 내부의 재귀 확인자가 모든 이전 단계와 같이 DNS 쿼리를 수신하면, 요청한 호스트-IP-주소 변환이 로컬 지속성 계층 내에 이미 저장되어 있는지도 확인한다.

# 5. 보안 관련 사항

- DNS 서버 사용 시 발생할 수 있는 흔한 리스크 두 가지는 다음과 같다.

### 5-1. DNS 하이재킹

- Redirection 공격으로 알려진 DNS 하이재킹은 DNS 쿼리가 잘못 처리되어 사용자를 거짓의 악성 웹사이트로 Redirection하는 경우 발생한다.
- 사용자 컴퓨터의 라우터를 장악하거나 DNS 통신을 가로채는 멀웨어를 설치하면 DNS 하이재킹이 발생한다.

### 5-2. 캐시 오염

- DNS 캐시 오염(cache poisoning)은 공격자가 DNS 서버에 대한 제어력을 갖고 입력된 IP 주소를 손상시키는 경우 발생한다.
- 그 뒤 거짓으로 입력된 IP 주소는 전 세계의 ISP에 전달되며, 캐시되어 public DNS 검색에 사용된다.
- 캐시 오염을 방지하기 위한 한 방법은 DNSSec를 사용하는 것이다.
- DNSSec는 안전한 DNS를 사용하고 암호화된 서명을 DNS 레코드에 할당하므로 레코드를 원래 상태와 다르게 변경할 수 없다.
- HTTPS와 유사하게 DNSSec은 쿼리 프로세스를 느리게 하는 강력한 암호화를 수행하지 않고도 DNS 레코드에 접근할 수 있도록 보안 계층을 추가한다.