# Overhead

---

# 정의

- 특정 작업을 수행하는 데 필요한 초과 또는 간접 계산 시간, 메모리, 대역폭 또는 기타 리소스의 조합이다.
- 통신 네트워크를 통해 데이터 페이로드를 안정적으로 전송하려면 원하는 페이로드 데이터 자체 이상의 전송이 필요하다. 또한, 원하는 데이터를 안정적으로 전송하는 데 필요한 다양한 제어 및 신호 데이터(TCP)를 보내는 것도 포함된다. 이 때 제어 신호가 곧 오버헤드가 된다.
- 예시로 통화를 생각하면, 통화를 하기 전에 번호를 눌러야 하는 필요성과 시간이 오버헤드이다. 즉 번호를 다이얼링하고 통화를 설정하는 것이 오버헤드라고 할 수 있다.
- 예를 들어 A라는 처리를 단순하게 실행한다면 10초 걸리는데, 안전성을 고려하고 부가적인 B라는 처리를 추가한 결과 처리시간이 15초 걸렸다면, 오버헤드는 5초가 된다. 또한 이 처리 B를 개선해 B'라는 처리를 한 결과, 처리시간이 12초가 되었다면, 이 경우 오버헤드가 3초 단축되었다고 말한다.
- 컴퓨터 공학에서의 overhead는 process 처리 시간의 편차 발생으로 인한 지연을 일컫는 개념이다.

# Type of Overhead

### Protocol overhead

- 이더넷 프레임, IP 패킷 및 TCP 세그먼트에는 모두 헤더가 있으며, TCP 연결에는 핸드셰이크 패킷이 필요하다. 따라서 하드웨어가 실제 데이터에 사용할 수 있는 전체 대역폭을 사용할 수 없다.
- 더 큰 패킷 크기를 사용하면 오버헤드를 줄일 수 있으며 UDP에는 더 작은 헤더가 있고 핸드셰이크가 없는 식이다.

### Data structure memory overhead

- 연결된 목록에는 포함된 각 요소에 대해 하나 이상의 포인터가 필요하다.
- 요소의 크기가 포인터와 같은 경우 이는 메모리 오버헤드가 50%인 반면 배열의 오버헤드는 잠재적으로 0%일 수 있음을 의미한다.

### Method call overhead

- 각 메서드 호출에는 스택 프레임 설정, 매개변수 복사 및 반환 주소가 필요하다.
- 이는 단일 모놀리식 기능으로 모든 작업을 수행하는 프로그램과 비교한 CPU 오버헤드를 나타낸다.
- 추가된 유지 관리 기능으로 인해 그만한 가치가 있지만 어떤 경우에는 과도한 메서드 호출이 성능에 상당한 영향을 미칠 수 있다.

# 설계

### **구현 선택**

- 프로그래머/소프트웨어 엔지니어는 각각 알려진 특성을 갖는 여러 알고리즘 , 인코딩 , 데이터 유형 또는 데이터 구조를 선택할 수 있다.
- 그 중에서 선택할 때 각각의 오버헤드도 고려해야 한다.

### **절충점**

- 소프트웨어 엔지니어링 에서 오버헤드는 새로운 제품에 기능을 포함할지 여부나 실제로 버그를 수정할지 여부를 결정하는 데 영향을 미칠 수 있다. 오버헤드가 높은 기능은 포함되지 않을 수도 있고, 포함하려면 큰 금전적 인센티브가 필요할 수도 있다. 소프트웨어 제공업체가 자사 제품의 버그를 잘 알고 있음에도 불구하고 이를 수정하는 데 따른 보상이 오버헤드로 인해 보상받을 가치가 없는 경우가 많다.
- 예를 들어, 암시적 데이터 구조 나 간결한 데이터 구조는 낮은 공간 오버헤드를 제공할 수 있지만 성능 저하(공간/시간 절충)가 발생한다.

### **소프트웨어의 런타임 복잡성**

- 알고리즘 복잡성은 일반적으로 Big O 표기법을 사용하여 지정된다 . 이것은 실행하는 데 걸리는 시간이나 사용하는 메모리의 양에 대해서는 언급하지 않지만 증가 정도는 입력 크기에 따라 다르다.
- 오버헤드는 기계마다 다르기 때문에 *의도적으로 이 계산에 포함되지 않는다. 반면 알고리즘의 기본 실행 시간은 그렇지 않다.*
- 이는 모든 종류의 리소스, 즉 (사소하지는 않지만) 복잡성과 오버헤드의 조합을 고려하는 알고리즘 효율성 과 대조되어야 한다 .

# 예시

### **컴퓨터 프로그래밍(런타임 및 계산 오버헤드)**

- 함수를 호출하면 약간의 런타임 오버헤드가 발생한다. 때때로 컴파일러는 이러한 함수 호출 중 일부를 인라인 처리하여 이 오버헤드를 최소화 할 수 있다 .
    
    <aside>
    💡 **인라인 확장** 또는 **인라인**
    함수 호출 사이트를 호출된 함수의 본문으로 바꾸는 수동 또는 컴파일러 최적화다. 인라인 확장은 매크로 확장과 유사하지만 소스 코드를 변경하지 않고 컴파일 중에 발생하는 반면, 매크로 확장은 컴파일 전에 발생하여 컴파일러에서 처리되는 다른 텍스트가 생성된다.
    
    </aside>
    

### **CPU 캐시**

- CPU 캐시 에서 "캐시 크기"(또는 **용량 )는** *캐시* 에 저장되는 데이터의 양을 나타낸다 . 예를 들어, "4KB 캐시"는 4KB의 데이터를 보유하는 캐시다. 이 예에서 "4KB"는 프레임, 주소 및 태그 정보와 같은 오버헤드 비트를 제외한다.

### **통신(데이터 전송 오버헤드)**

- 통신 네트워크를 통해 데이터 페이로드를 안정적으로 전송 하려면 페이로드 자체 이상의 전송이 필요하다. 또한 목적지에 도달하는 데 필요한 다양한 제어 및 신호 데이터( TCP )를 보내는 것도 포함된다. 이는 추가 데이터가 메시지의 본질적인 의미에 기여하지 않기 때문에 소위 **프로토콜 오버헤드를 생성힌다.**
- 전화 통신 에서는 번호 다이얼링 및 통화 설정 시간이 오버헤드이다. 양방향(그러나 반이중 ) 무선에서는 충돌을 방지하는 데 필요한 "over" 및 기타 신호를 사용하는 것이 오버헤드다.
- 프로토콜 오버헤드는 비응용 프로그램 바이트 (프로토콜 및 프레임 동기화 )를 메시지의 총 바이트 수로 나눈 비율로 표현될 수 있다.

### **인코딩 및 데이터 구조(크기 오버헤드)**

- 정보와 데이터의 인코딩 에도 오버헤드가 발생한다.
- 날짜 및 시간 *"2011-07-12 07:18:47"은* 32비트 부호 있는 정수를 사용하여 Unix 시간으로 표현될 수 있으며 4바이트만 사용한다.
- ISO 8601 형식의 UTF-8 인코딩 문자열로 표현 된 날짜는 19바이트를 소비하며 이는 이진 정수 표현에 비해 375%의 크기 오버헤드이다. XML 로서 이 날짜는 218자의 오버헤드를 사용하여 다음과 같이 작성할 수 있으며 인덱스 1을 사용하여 CHANGEDATE라는 의미 컨텍스트를 추가할 수 있다. `1310447927` `2011-07-12 07:18:47`

```jsx
<?xml version="1.0" 인코딩="UTF-8"?> 
<datetime qualifier= "changedate" index= "1" > <연도 > 2011 </year> <month> 07 </month> <day> 12 </day> <시간> 07 </시간> <분> 18 < /분> <초> 47 </ 초 > </datetime>
```

- UTF-8로 인코딩된 XML에서 생성된 349바이트는 원래 정수 표현에 비해 8625%의 크기 오버헤드와 관련이 있다.

### **파일 시스템**

- 파일 자체 외에도 컴퓨터 파일 시스템은 디렉토리 이름 및 목록, 파일 이름, 파일의 섹터 위치, 마지막 수정 및 생성 날짜 및 시간과 같은 속성, 파일 조각화 및 작성 방법을 저장하기 위해 공간의 일부를 차지한다.
- 많은 작은 파일은 적은 수의 큰 파일보다 더 많은 오버헤드를 생성한다.